自动化编译工具

#变量的定义
CC := gcc
TARGET := hello.out

#变量的使用
$(TARGET) : func.o main.o
    $(CC) -o $(TARGET) func.o main.o

   1. 简单赋值        :=
   2. 递归赋值        =
   3. 条件赋值        ?=  如果变量未定义，使用赋值符号中的值定义变量，如果已定义，赋值无效
    4. 追加赋值        +=

1、自动变量

$@   当前规则中触发命令被执行的目标

$^    当前规则中的所有依赖

$<    当前规则中的第一个依赖

变量值的替换
1.1 使用指定字符替换变量值中的后缀字符
1.2 语法格式：$(var:a=b)或${var:a=b}

变量的模式替换
2.1 使用%保留变量值中的指定字符，替换其他字符
2.2 语法格式： $(var:a=b)或${var:a=b}

变量值的嵌套引用
 5.1 一个变量名之中可以包含对其他变量的引用
 5.2 嵌套引用的本质是使用一个变量表示另外一个变量

@ 不显示命令行信息

override关键字
使用override关键字以后，makefile中定义的变量不会因为make的命令行变量而改变

define关键字

    定义多行变量时，使用define关键字，同时可以配合override关键字防止变量被覆盖，

define定义的变量等价于使用=定义的变量
define foo
i'm fool!
endef

override define foo
i'm fool!
endef

运行make时。指定-e选项，可以优先使用环境变量

变量在不同makefile之间的传递方式
    10.1 直接在外部定义环境变量进行传递
    10.2 使用export定义变量进行传递
    10.3 定义make命令行变量进行传递

目标变量
    作用域只在指定目标及连带规则中

深入自定义函数
        1、 自定义函数是一个多行变量，无法直接调用
        2、 自定义函数是一个过程调用，没有任何的返回值
        3、 自定义函数用于定义命令集合，并应用于规则中

调用自定义的方法是在规则中，$(call funcname)，这种方式调用
define定义的函数，必须要在规则中通过call才能调用，否则，就只是当作一个变量
define funcname
    echo 111
endef

make支持三各通配符：“*”，“?”和“[...]”
