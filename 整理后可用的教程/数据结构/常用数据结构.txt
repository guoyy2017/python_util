LSM-tree The Log-Structured Merge-Tree (LSM-Tree)
LSM-tree 是专门为 key-value 存储系统设计的
LSM-tree 在 NoSQL 系统里非常常见，基本已经成为必选方案了
LSM-tree 主要针对的场景是写密集、少量查询的场景
LSM-tree 被用在各种键值数据库中，如 LevelDB，RocksDB，还有分布式行式存储数据库 Cassandra 也用了 LSM-tree 的存储架构

B树
数据库存数据
B+树
数据库存索引

红黑树  插入和查找时间O(logN)
HashMap 结构中，减少插入和查找时间的结构

字典树 最短自字符串


跳跃表 skiplist
跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针(注：可以理解为维护了多条路径)，从而达到快速访问节点的目的
(1)跳跃表的每一层都是一条有序的链表。
(2)维护了多条节点路径。
(3)最底层的链表包含所有元素。
(4)跳跃表的空间复杂度为 O(n)。
(5)跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
跳跃表作为有序集合键的底层实现之一
一个跳表应该有几个层（level）组成；
通常是10-20层，leveldb中默认为12层

ziplist 压缩列表
zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数
zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。
zllen: ziplist的节点（entry）个数
entry: 节点
zlend: 值为0xFF，用于标记ziplist的结尾
节点的布局(entry)
每个节点由三部分组成：prevlength、encoding、data
prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist
encoding: 当前节点的编码规则，下文会详细说
data: 当前节点的值，可以是数字或字符串

entry的前8位小于254，则这8位就表示上一个节点的长度
entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。
整数节点分为6类
整数节点的encoding的长度为8位，其中高2位用来区分整数节点和字符串节点（高2位为11时是整数节点），低6位用来区分整数节点的类型
最后一种encoding是存储整数0~12的节点的encoding，它没有额外的data部分，encoding的高4位表示这个类型，低4位就是它的data
字符串节点分为3类
当data小于63字节时(2^6)，节点存为上图的第一种类型，高2位为00，低6位表示data的长度。
当data小于16383字节时(2^14)，节点存为上图的第二种类型，高2位为01，后续14位表示data的长度。
当data小于4294967296字节时(2^32)，节点存为上图的第二种类型，高2位为10，下一字节起连续32位表示data的长度

快速列表quicklist
采用sdlist和ziplist来实现quicklist
sdlist充当map中控器的作用，ziplist充当占用连续内存空间数组的作用。quicklist本身是一个双向无环链表，它的每一个节点都是一个ziplist
list-max-ziplist-size -2
参数为正，表示按照数据项个数来限定每个节点中的元素个数
参数为负，表示按照字节数来限定每个节点中的元素个数，它只能取-1~-5这五个数
-1 每个节点的ziplist字节大小不能超过4kb
-2 每个节点的ziplist字节大小不能超过8kb
-3 每个节点的ziplist字节大小不能超过16kb
-4 每个节点的ziplist字节大小不能超过32kb
-5 每个节点的ziplist字节大小不能超过64kb

在quicklist的源码中提到了一个LZF的压缩算法
list-compress-depth 0
0 特殊值，表示不压缩
1 表示quicklist两端各有一个节点不压缩，中间的节点压缩
2 表示quicklist两端各有两个节点不压缩，中间的节点压缩
3 表示quicklist两端各有三个节点不压缩，中间的节点压缩
以此类推。

双端链表sdlist


