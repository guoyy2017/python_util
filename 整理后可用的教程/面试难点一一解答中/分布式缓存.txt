缓存的更新模式
---------------------------------------------------------------------------------
Cache Aside模式
读取失效：cache数据没有命中，查询DB，成功后把数据写入缓存
读取命中：读取cache数据
更新：把数据更新到DB，失效缓存

Read/Write Through模式
缓存代理了DB读取、写入的逻辑，可以把缓存看成唯一的存储。

Write Behind Caching(Write Back)模式
这种模式下所有的操作都走缓存，缓存里的数据再通过异步的方式同步到数据库里面。所以系统的写性能能够大大提升了。


缓存失效策略
---------------------------------------------------------------------------------
一般而言，缓存系统中都会对缓存的对象设置一个超时时间，避免浪费相对比较稀缺的缓存资源。对于缓存时间的处理有两种，分别是主动失效和被动失效。
主动失效
主动失效是指系统有一个主动检查缓存是否失效的机制，比如通过定时任务或者单独的线程不断的去检查缓存队列中的对象是否失效，如果失效就把他们清除掉，避免浪费。主动失效的好处是能够避免内存的浪费，但是会占用额外的CPU时间。

被动失效
被动失效是通过访问缓存对象的时候才去检查缓存对象是否失效，这样的好处是系统占用的CPU时间更少，但是风险是长期不被访问的缓存对象不会被系统清除。


缓存淘汰策略
---------------------------------------------------------------------------------
缓存淘汰，又称为缓存逐出(cache replacement algorithms或者cache replacement policies)，是指在存储空间不足的情况下，缓存系统主动释放一些缓存对象获取更多的存储空间。

对于大部分内存型的分布式缓存（非持久化），淘汰策略优先于失效策略，一旦空间不足，缓存对象即使没有过期也会被释放。这里只是简单介绍一下，相关的资料都很多，一般LRU用的比较多，可以重点了解一下。

FIFO
先进先出（First In First Out）是一种简单的淘汰策略，缓存对象以队列的形式存在，如果空间不足，就释放队列头部的（先缓存）对象。一般用链表实现。

LRU
最近最久未使用（Least Recently Used），这种策略是根据访问的时间先后来进行淘汰的，如果空间不足，会释放最久没有访问的对象（上次访问时间最早的对象）。比较常见的是通过优先队列来实现。

LFU
最近最少使用（Least Frequently Used），这种策略根据最近访问的频率来进行淘汰，如果空间不足，会释放最近访问频率最低的对象。这个算法也是用优先队列实现的比较常见。

缓存穿透
---------------------------------------------------------------------------------
DB中不存在数据，每次都穿过缓存查DB，造成DB的压力。一般是网络攻击
解决方案：放入一个特殊对象（比如特定的无效对象，当然比较好的方式是使用包装对象）


缓存击穿
---------------------------------------------------------------------------------
在缓存失效的瞬间大量请求，造成DB的压力瞬间增大
解决方案：更新缓存时使用分布式锁锁住服务，防止请求穿透直达DB



缓存雪崩
---------------------------------------------------------------------------------
大量缓存设置了相同的失效时间，同一时间失效，造成服务瞬间性能急剧下降
解决方案：缓存时间使用基本时间加上随机时间




---------------------------------------------------------------------------------



