快慢指针算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
查找链表中间节点
定义两个指针，一个快指针，一个慢指针，当快指针遍历到尾节点的时候，慢指针刚好遍历到中间的节点。
当节点个数为奇数时，中间节点只有一个，当节点个数为偶数时，慢指针指向的节点和它的后继都是中间节点。
这种办法时间只需要遍历一次，且未开辟新空间，因此时间复杂度为O(n),空间复杂度为O(1)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
找到链表的倒数第个节点
与上面一样，不过这里的移动方式要变一下，之前快慢指针同时起步，slow= slow.next ;fast = fast.next.next,这样做，快指针比慢指针整整快了一倍。
想要找倒数第k个节点，可以让快指针先行k步，然后两个指针一起往后走，当快指针到达尾节点的时候，慢指针指向的就是前k个节点。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
检测单链表是否有环，返回环的入口
检测单链表是否有环：
定义两个指针，一个快一个慢，两个指针刚开始时都指向链表的头节点，之后快指针每次前进两步，慢指针每次前进一步，如果他们相遇了（fast= low），说明快指针已经转了一圈回来了，也就说明链表有环。
返回环的入口：
同样定义两个指针，一个指向头节点，另一个指向相遇点，两个指针同时向后走，他们的第一次相遇点就是环的入口。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


最大堆和最小堆查找中位数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
一半的大数放入最小堆，一半的小数据放到最大堆，就能找到中位数
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



同余定理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系
用于求数组和能被K整除数据
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


位操作掩码处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
int a = ~0; //一连串的1
int left = a << 6;左移动 左1右0
int right = (1 << 6) - 1;左移动 -1 左0右1
int mask = left|right;//生成左右1，中间0 的mask
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


两个数互质 容器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
可以按照倒水顺序，得出1，2到容量的各个数
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
x & ~x = 0;
x & ~0 = x;
三进制运算   00>01>10>00
b = (b ^ n) & ~a;
a = (a ^ n) & ~b;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(1) 常用的等式： -n=~（n-1）=~n+1
(2) 获取整数n的二进制中最后一个1: n&~(n-1)或者n&(-n)。例如n=010100,则-n=101100，n&(-n)=000100。
(3) 去掉整数n的二进制中最后一个1: n&(n-1)。例如n=010100,n-1=010011,则n&(n-1)=010000。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
左右累乘/累加
左边开始累积加/乘，结果缺少右边的值
右边开始累积加/乘，结果缺少左边的值
左右相加/乘刚好是结果
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
基数估计的应用比较广泛，对于存储空间和实时要求比较高，但是精度要求能容忍一定误差的时候，基数估计是个很好的选择。
Linear Counting
LogLog Counting
Adaptive Counting
HyperLogLog Counting
HyperLogLog++ Counting

哈希函数采用murmurhash32（HyperLogLog++采用murmurhash64）
Redis规定分桶个数为16384个，每一个桶内的数据采用6bit大小来存放
Redis此处存放的不是该元素，而是存放第一次出现“1”的位置的值，6bit可以表示0~64位，即可以支持[公式]个基数。
registers部分占用内存为（16384*6+7）/8 = 12288个字节，另外加上HLL结构的头占用了16个字节，加起来一共12304个字节，也就是说一个hyperloglog键占用了12KB左右的大小，最多可以计算[公式]个不同元素的基数。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
五个常用好用的数据结构(BloomFilter、Hyperloglog等)
https://blog.csdn.net/keyboard2000/article/details/91424889
各种算法数据结构
Bloom filter、Count–min sketch、Cuckoo filter、HyperLogLog、Kinetic hanger、Kinetic heater、Locality-sensitive hashing、MinHash、Quotient filter、Random binary tree、Random tree、Rapidly-exploring random tree、SimHash、Skip list、Treap

Hyperloglog
基数统计（cardinality estimation）是指用概率算法的思想，估计一个集合中不同的数的个数。
BloomFilter
判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定
MinHash是一种基于 Jaccard Index 相似度的算法，用于快速估计两个集合的相似度
Count-min Sketch 是一个概率数据结构，和BloomFilter的统计机制类似，用作统计数据流中事件的频率
T-Digest算法则通过一定计算，将数据集的分布情况粗略地记录下来，从而估计出指定的分位数值。

通过牺牲准确性来提升时间与空间的利用效率的，在大量数据的场景有很大的应用价值
stream-lib是比较有名的java实时计算与基数统计工具库，有兴趣的可以翻下github： https://github.com/addthis/stream-lib

<!-- https://mvnrepository.com/artifact/com.addthis/stream-lib -->
<dependency>
    <groupId>com.addthis</groupId>
    <artifactId>stream-lib</artifactId>
    <version>3.0.0</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.clearspring.analytics/stream -->
<dependency>
    <groupId>com.clearspring.analytics</groupId>
    <artifactId>stream</artifactId>
    <version>2.9.8</version>
</dependency>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
负载均衡算法

轮询法：
加权轮询法：加权轮询分为：简单的轮询、平滑的轮询
平滑的轮询，就是把每个不同的服务，平均分布
随机法：
加权随机法：
IP_Hash算法：

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



