快慢指针算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
查找链表中间节点
定义两个指针，一个快指针，一个慢指针，当快指针遍历到尾节点的时候，慢指针刚好遍历到中间的节点。
当节点个数为奇数时，中间节点只有一个，当节点个数为偶数时，慢指针指向的节点和它的后继都是中间节点。
这种办法时间只需要遍历一次，且未开辟新空间，因此时间复杂度为O(n),空间复杂度为O(1)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
找到链表的倒数第个节点
与上面一样，不过这里的移动方式要变一下，之前快慢指针同时起步，slow= slow.next ;fast = fast.next.next,这样做，快指针比慢指针整整快了一倍。
想要找倒数第k个节点，可以让快指针先行k步，然后两个指针一起往后走，当快指针到达尾节点的时候，慢指针指向的就是前k个节点。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
检测单链表是否有环，返回环的入口
检测单链表是否有环：
定义两个指针，一个快一个慢，两个指针刚开始时都指向链表的头节点，之后快指针每次前进两步，慢指针每次前进一步，如果他们相遇了（fast= low），说明快指针已经转了一圈回来了，也就说明链表有环。
返回环的入口：
同样定义两个指针，一个指向头节点，另一个指向相遇点，两个指针同时向后走，他们的第一次相遇点就是环的入口。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


最大堆和最小堆查找中位数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
一半的大数放入最小堆，一半的小数据放到最大堆，就能找到中位数
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



同余定理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系
用于求数组和能被K整除数据
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


位操作掩码处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
int a = ~0; //一连串的1
int left = a << 6;左移动 左1右0
int right = (1 << 6) - 1;左移动 -1 左0右1
int mask = left|right;//生成左右1，中间0 的mask
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


两个数互质 容器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
可以按照倒水顺序，得出1，2到容量的各个数
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<