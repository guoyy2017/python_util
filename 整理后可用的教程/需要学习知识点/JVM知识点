关闭偏向锁延迟
java6和7中默认启用，但是会在程序启动几秒后才激活，如果需要关闭延迟，
-XX:BiasedLockingStartupDelay=0。

关闭偏向锁
JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false,那么程序默认会进入轻量级锁状态。

ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。
ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，
而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。
ReenTrantLock提供了一种能够中断等待锁的线程的机制，
通过lock.lockInterruptibly()来实现这个机制。

Atomic包提供了一个类AtomicStampedReference来解决ABA的问题

ThreadPoolExecutor
cpu密集型可以配置可能小的线程,比如 n + 1个线程。
io密集型可以配置较多的线程，如 2n个线程。
混合型可以拆成io密集型任务和cpu密集型任务，

对象逃逸状态
全局逃逸（GlobalEscape）
参数逃逸（ArgEscape）
没有逃逸

逃逸分析的 JVM 参数如下：
开启逃逸分析：-XX:+DoEscapeAnalysis
关闭逃逸分析：-XX:-DoEscapeAnalysis
显示分析结果：-XX:+PrintEscapeAnalysis
默认设置为启用状态，可以不用额外加这个参数

锁消除的 JVM 参数如下：
开启锁消除：-XX:+EliminateLocks
关闭锁消除：-XX:-EliminateLocks

标量替换的 JVM 参数如下：
开启标量替换：-XX:+EliminateAllocations
关闭标量替换：-XX:-EliminateAllocations
显示标量替换详情：-XX:+PrintEliminateAllocations

栈上分配
当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。



垃圾回收机制
标记->清理->压缩
逐一标记和压缩 Java 虚拟机里的所有对象非常低效
Stop the World 事件
Major GC 也会触发STW（Stop the World）


里氏替换原则
********** ********** ********** ********** ********** ********** ********** **********
1、开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科
3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5、迪米特法则（最少知道原则）（Demeter Principle）
为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承
********** ********** ********** ********** ********** ********** ********** **********


工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的
享元模式通过共享对象来避免创建太多的对象
String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子

可靠的分布式锁应该具备以下特性
1.互斥性：作为锁，需要保证任何时刻只能有一个客户端(用户)持有锁
2.可重入： 同一个客户端在获得锁后，可以再次进行加锁
3.高可用：获取锁和释放锁的效率较高，不会出现单点故障
4.自动重试机制：当客户端加锁失败时，能够提供一种机制让客户端自动重试
