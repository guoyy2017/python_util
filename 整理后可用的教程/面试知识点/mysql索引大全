https://blog.csdn.net/guzhangyu12345/article/details/96423704
聚集索引
聚集索引：指索引项的排序方式和表中数据记录排序方式一致的索引 
一个表只能有一个聚集索引
聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量

非聚集索引： 索引顺序与物理存储顺序不同
非聚集索引必须是稠密索引

聚簇索引
一种数据存储方式 数据行和相邻的键值紧凑的存储在一起
一个表只能有一个聚族索引
聚族索引将索引和数据保存在同一个B-Tree中，因此从聚族索引中获取数据通常比在非聚族索引中查找更快

稠密索引
稠密索引：每个索引键值都对应有一个索引项
稠密索引能够比稀疏索引更快的定位一条记录。但是，稀疏索引相比于稠密索引的优点是：它所占空间更小，且插入和删除时的维护开销也小。

稀疏索引
稀疏索引：相对于稠密索引，稀疏索引只为某些搜索码值建立索引记录；在搜索时，找到其最大的搜索码值小于或等于所查找记录的搜索码值的索引项，然后从该记录开始向后顺序查询直到找到为止。


MyIsam 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。主索引和辅助索引没有区别都是非聚集索引
主索引和辅助索引没有区别都是非聚集索引。
InnoDB默认对主键建立聚簇索引。
mysql innodb引擎的聚集索引、聚簇索引都默认是主键索引 该索引是稠密索引



锁知识
行锁 record lock
间隙锁 gap lock
区间锁 next-key lock
隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。
UPDATE和DELETE时，除了对唯一索引的唯一搜索外都会获取gap锁或next-key锁。即锁住其扫描的范围。
影响到的字段不是唯一的，会变为区间锁
如果是唯一的，会取得 行锁

上共享锁的写法：lock in share mode
上排它锁的写法：for update
insert ，delete ， update在事务中都会自动默认加上排它锁
临键锁是行锁+间隙锁
共享锁/排他锁都只是行锁，与间隙锁无关
请求共享锁/排他锁时，获取到的结果却可能是行锁，也可能是间隙锁，
也可能是临键锁，这取决于数据库的隔离级别以及查询的数据是否存在
意向共享锁/意向排他锁属于表锁
（next-key lock）,他是前开后闭原则


Innodb插入数据效率
顺序插入效率高于乱序，乱序page使用率不高
xtrabackup的附带功能查看数据文件
8并发的sysbench进行OLTP测试


事务
事务四大属性
分别是原子性、一致性、隔离性、持久性。

数据库事务的隔离级别有4个，由低到高依次为
Read uncommitted(未授权读取、读未提交)、
Read committed（授权读取、读提交）、
Repeatable read（可重复读取）、
Serializable（序列化），
这四个级别可以逐个解决脏读、不可重复读、幻象读这几类问题。


事务并发问题
第一类丢失更新：在没有事务隔离的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出， 导致对数据的两个修改都失效了。
脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
第二类丢失更新：不可重复读的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。
幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了
幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样

redo undo
重做日志(redo log)用来保证事务的持久性
物理Redo日志
逻辑Redo日志
Redo log的主要作用是用于数据库的崩溃恢复
一是内存中重做日志缓冲 (redo log buffer),是易失的，在内存中
二是重做日志文件 (redo log file)，是持久的，保存在磁盘中
写入redo日志。注意的是先修改数据，后写日志
redo日志比数据页先写回磁盘
聚集索引、二级索引、undo页面的修改，均需要记录Redo日志。
第一步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第二步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值
第三步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式
第四步：定期将内存中修改的数据刷新到磁盘中
fsync是一种系统调用操作，其fsync的效率取决于磁盘的性能，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能
innodb_flush_log_at_trx_commit来控制的，该参数可以控制 redo log刷新到磁盘的策略

undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。
undo是一种逻辑日志，有两个作用：
用于事务的回滚
MVCC
undo日志用于事务的回滚操作进而保障了事务的原子性
DML操作修改聚簇索引前，记录undo日志
二级索引记录的修改，不记录undo日志
undo页面的修改，同样需要记录redo日志
undo log分为：
insert undo log
update undo log
purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。


LOCK TALBES虽然可以给InnoDB加表级锁
仅当autocommit=0、innodb_table_lock=1（默认设置）时，
InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁

InnoDB存储引擎在设计时是将根节点常驻内存的，
也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作



