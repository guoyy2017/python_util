读写分离配置
mysql-proxy 实现读写分离
MyCat实现MySQL读写分离
mysql-connector-java驱动本身也提供了读写分离的功能，使用起来也非常简单
jdbc:mysql:replication://192.168.41.130:3306,192.168.41.130:3307/test?useUnicode=true&characterEncoding=utf-8
url的第一个mysql是作为master库，后面的所有mysql都是slave库
可以通过mysql-router中间件去实现读写分离
Sharding-JDBC实现读写分离


索引问题
MyISAM引擎使用B+树作为索引结果，叶节点的data域存放的是数据记录的地址。
在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

InnoDB索引实现
同样是B+树，实现方式却完全不同。InnoDB表数据文件本身就是一个索引结构，树的叶节点data域保存了完整的数据记录，这种索引叫做聚集索引。
辅助索引
InnoDB的所有辅助索引都引用主键作为data域。下图为定义在Col3上的一个辅助索引
聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

Hash索引，其检索效率非常高的一种精确定位索引。

Innodb和MyISAM默认的索引是Btree索引；而Mermory默认的索引是Hash索引
BTree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量
Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。




************************************************************
mysql事务级别
SERIALIZABLE serializable 序列化 ；一个个事务排成序列的形式。事务一个挨一个执行，等待前一个事务执行完，后面的事务才可以顺序执行
REPEATEABLE READ repeatable read 可重复读；安全上不如serializable，但是性能上比serializable强很多，但会造成幻读。
隔离级别：导致幻读，同时开启两个事务，事务A和事务B，当事务A修改了数据，并且提交了，事务B此时查看不到事务A已经提交了的数据，这样保持事务B先后两次查询结果的一致性，当事务B执行update操作的时候，是可以更改事务A提交了的update，insert数据，执行过update操作之后再次select发现数据前后查询不一致！(幻读)
READ COMMITED read committed 提交的可读；(oracle默认)
READ UNCOMMITED read uncommitted 未提交的可读；（mysql 默认）别的事务可以查看的到使用 当前事务还没提交的 数据；会 脏读，幻读，不可重复读。
幻读：一个事务的查询中查询两次数据，数据不一致！同时开启事务A，事务B。事务A查询一张表中的数据后，事务B修改update了事务A查询的表并做了提交，事务A再次查询这张表，发现数据的不一致！

事务四大属性
分别是原子性、一致性、隔离性、持久性。
1、原子性（Atomicity）
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
2、一致性（Consistency）
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。举例来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。
3、隔离性（Isolation）
隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。
4、持久性（Durability）
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务已经正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成。否则的话就会造成我们虽然看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。这是不允许的。

并发的情况下可能出现如下问题
更新丢失（Lost update） 
脏读（Dirty Reads）
不可重复读（Non-repeatable Reads） 
幻象读 
Read uncommitted(未授权读取、读未提交)： 
如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。这样就避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。
Read committed（授权读取、读提交）： 
读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
Repeatable read（可重复读取）： 
可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了在一个事务内两次读到的数据是一样的，因此称为是可重复读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。（读取数据的事务）这可以通过“共享读锁”和“排他写锁”实现。
Serializable（序列化）： 
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 


DDL会引起metadata lock,导致请求连环阻塞,甚至是查询请求.
MySQLDump和XtraBackup的flush table命令会引起waiting for table连环阻塞,同样也会阻塞查询请求.
选用可重复读事务隔离级别,会开启间隙锁.他锁定的内容比实际需要的要多,并且很可能导致死锁.
MVCC多版本并发控制
普通的Select（一致性读或者说快照读）可以以非锁定的形式读取数据

在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。


************************************************************
事务的并发问题

　　1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表



************************************************************
锁
在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

记录锁
间隙锁
读锁 (S锁)
写锁 (X锁)
MVCC 读不加锁
MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。

MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）

共享锁和排他锁
InnoDB也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种

意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所以，可以说InnoDB的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX）
意向锁是InnoDB自动加的，不需用户干预。
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE

InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁

间隙锁（Next-Key锁）
LOCK TABLES虽然可以给InnoDB加表级锁
UNLOCK TABLES释放表锁


************************************************************
MySQL的八种锁
行锁（Record Locks）
间隙锁（Gap Locks）
临键锁（Next-key Locks）
共享锁/排他锁（Shared and Exclusive Locks）
意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）
插入意向锁（Insert Intention Locks）
自增锁（Auto-inc Locks）
实际上，MySQL官网中还提到了一种预测锁，这种锁主要用于存储了空间数据的空间索引

RC隔离级别下，不存在间隙锁
RR隔离级别下，存在间隙锁
在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行
************************************************************

************************************************************
mysql binlog的格式三种：statement,row,mixed
repeatable存在间隙锁会使死锁的概率增大，在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行

binlog有几种格式？
OK，三种，分别是
statement:记录的是修改SQL语句
row：记录的是每行实际数据的变更
mixed：statement和row模式的混合
************************************************************


************************************************************

基于Galera的MySQL高可用集群， 是多主数据同步的MySQL集群解决方案，使用简单，没有单点故障，可用性高。
优点：
多主写入，无延迟复制，能保证数据强一致性;
有成熟的社区，有互联网公司在大规模的使用;
自动故障转移，自动添加、剔除节点;
缺点：
需要为原生MySQL节点打wsrep补丁
只支持innodb储存引擎
至少三节点;

Paxos 算法解决的问题是一个分布式系统如何就某个值(决议)达成一致。这个算法被认为是同类算法中最有效的。Paxos与MySQL相结合可以实现在分布式的MySQL数据的强一致性。
优点：
多主写入，无延迟复制，能保证数据强一致性;
有成熟理论基础;
自动故障转移，自动添加、剔除节点;
缺点：
只支持innodb储存引擎
至少三节点;

